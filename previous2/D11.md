シリーズ第11回、**Day 11** のコンテンツです。  
昨日は `fetch()` を使って、インターネットの向こう側からデータ（JSON）を取り寄せることに成功しました。  
でも、そのデータはまだコンソールの中にしかありません。

今日は、そのデータを **「料理（加工）」** して、ユーザーが見える **「お皿（ブラウザの画面）」** に盛り付ける工程を学びます。  
さらに、データが届くまでの待ち時間を「おもてなし」に変える、プロの気配りテクニックも登場しますよ！

-----

# 🕰️ Day 11：取得したデータを画面に出す ～UIへの反映～

## 🍳 11.1 素材は揃った！あとは盛り付けだけ

<img src="./sasie/D11_plating_data.png" width="800" />

昨日の実験で、犬の画像APIからこんなデータが届きましたね。

```json
{
    "message": "https://images.dog.ceo/.../terrier.jpg",
    "status": "success"
}
```

この `message` の中に入っているURL。  
これを、HTMLの `<img src="...">` の中に入れてあげれば、画面にワンちゃんが表示されるはずです。

<img src="./images/Gemini_Generated_Image_hntiq3hntiq3hnti.png" width="250"/><br>

Day 9までで作った「運動記録アプリ」で、`innerHTML` や `value` を書き換えたのを覚えていますか？  
やることはあれと全く同じです！

1.  **データを取り寄せる（fetch）**
2.  **表示する場所を探す（getElementById）**
3.  **書き換える（src = ...）**

この3ステップで、アプリは完成します。

![データから画面への盛り付け](./zukai/D11_data_plating.svg)

-----

### 🐶ウィッチ・ワン？🐶ワンちゃんはどれ？
<img src="./images/ChatGPT Image 2025年12月23日 13_37_31.png" width="200" height="200" /><img src="./images/Gemini_Generated_Image_ft0gqift0gqift0g.png" width="200" height="200"/><br>
<img src="./images/Gemini_Generated_Image_3z6h6e3z6h6e3z6h.png" width="200" height="200"/><img src="./images/Gemini_Generated_Image_jn8nvkjn8nvkjn8n.png" width="200" height="200"/><br>
<img src="./images/Gemini_Generated_Image_5t3n85t3n85t3n85.png" width="200" height="200"/><img src="./images/ChatGPT Image 2025年12月24日 13_52_29.png" width="200" height="200"/><br>

---

## 🐶 11.2 ワンちゃん表示アプリを作ろう


では、実際にコードを書いてみましょう。  
HTMLファイルに、画像を表示するための「枠」を用意します。

### HTML

```html
<h1>きょうのわんこ🐶</h1>
<button id="fetch-btn">新しい写真を見る！</button>

<div id="dog-container">
    <img id="dog-image" src="" alt="ここに犬が出るよ" width="300">
</div>
```

### JavaScript

```javascript
// 1. ボタンと画像の要素を見つけておく
const btn = document.getElementById('fetch-btn');
const img = document.getElementById('dog-image');

// 2. データを取ってきて表示する関数
async function showDog() {
    console.log('🚀 データを注文しました...');
    
    // APIからデータを取る（2段階待機！）
    const response = await fetch('https://dog.ceo/api/breeds/image/random');
    const data = await response.json();

    console.log('📦 データ到着！ URL:', data.message);

    // 3. 画像の src を書き換える（盛り付け！）
    img.src = data.message;
}

// ボタンを押したら実行！
btn.addEventListener('click', showDog);
```

### 🧠 初心者さんの、心の旅

  * 「ボタンをポチッ！ …（一瞬の間）… わっ！ 写真が出た！」
  * 「コンソールにあった文字（URL）を、`img.src` に代入するだけで、ブラウザが勝手に画像を読み込んでくれるんだ。」
  * 「なんか私、本当に『アプリ』を作ってる感じがする…！」

<img src="./images/Gemini_Generated_Image_4r0shl4r0shl4r0s.png" width="300">

### 🖼️ 設計図：コードのつながり

「文字ばっかりで、どこが何だか…」  
そんな時は、コード全体を一つの「お店」としてイメージしてみましょう。

*   **HTML（店舗）:** お客さんが見る場所。そこに「空っぽの額縁（img）」と「スイッチ（button）」がある。
*   **JavaScript（店員）:** 裏で動く人。「スイッチが押されたら（Event）」→「倉庫から絵を取ってくる（fetch）」→「額縁にはめる（src）」というマニュアル通りに動く。

この2つを `getElementById`（名札）で紐付けるのがポイントです！

<img src="./sasie/D11_blueprint_shop.png" width="600" />

-----

### 🧩 レベルアップ：リストを作ってみよう！

以前の学習教材の「運動トラッカー」では、`document.createElement` や `appendChild` を使って、テーブルの行 (`<tr>`) を追加しましたよね？  
Fetch APIで取ってきたデータでも、やることは同じです！

もし「犬種リスト」のような配列データが届いたら…？

```javascript
// 1. 親要素（リストの箱）を見つける
const list = document.getElementById('dog-list');

// 2. データ（配列）をループする
data.forEach(dogName => {
    // 3. 要素を作る (createElement)
    const li = document.createElement('li');
    li.textContent = dogName; // "柴犬" とか
    
    // 4. 箱に入れる (appendChild)
    list.appendChild(li);
});
```

「APIで取る」→「ループする」→「要素を作って追加する」。  
これが、世の中のSNSやニュースサイトの仕組みそのものなんです！

```mermaid
graph TD
    Data["📦 データ (Json)<br>['柴犬', '秋田犬']"]
    
    subgraph JS [JavaScriptの世界]
        Loop["🔄 forEachで回す"]
        Make["🔨 &lt;li&gt;柴犬&lt;/li&gt; を作る"]
        Append["📥 &lt;ul&gt; の中に追加"]
    end
    
    UI["📺 ブラウザの画面<br>・柴犬<br>・秋田犬"]
    
    Data --> Loop --> Make --> Append --> UI

```

-----

<img src="./images/Gemini_Generated_Image_bmbft8bmbft8bmbf.png" width="200" height="200"/><img src="./images/Gemini_Generated_Image_x29iqyx29iqyx29i.png" width="200" height="200"/><br>

---

## ⏳ 11.3 「空白の時間」を埋めるおもてなし

さて、ここで一つ問題があります。  
インターネットが遅い場所でこのボタンを押すと、どうなるでしょうか？

1.  ボタンを押す。
2.  **（……シーン……）**
3.  3秒後、急に画像が切り替わる。

この「シーン」としている間、ユーザーは **「あれ？ ボタン押せてないかな？」** と不安になって、何度もボタンを連打してしまうかもしれません。

<img src="./images/Gemini_Generated_Image_si1qwcsi1qwcsi1q.png" width="300"/>
 

そこで大切なのが、 **「ローディング表示（Loading State）」** です。  
「ただいま準備中です！」という看板を出すだけで、ユーザーは安心して待つことができます。

### 🌀 ローディングの仕組み

1.  処理が始まったら、**「読み込み中…」を表示**する。
2.  `await` でデータを待つ。
3.  終わったら、**「読み込み中…」を消す**。

ここで役に立つのが、Day 8で習った **`finally`（ファイナリー）** です！

-----

## 🛡️ 11.4 実践！ローディング付きのコード

HTMLに「読み込み中」のメッセージを追加して、JavaScriptで出し入れしてみましょう。

### HTML（追加）

```html
<p id="loading-text" style="display: none;">⏳ 読み込み中... 準備してます！</p>
```

### JavaScript（改良版）

```javascript
const loadingText = document.getElementById('loading-text');

async function showDogSafe() {
    // 1. カーテンを開ける（表示オン！）
    // style.display = 'block' は「見えるようにするスイッチ」です
    loadingText.style.display = 'block';
    
    try {
        // データを取る
        const response = await fetch('https://dog.ceo/api/breeds/image/random');
        const data = await response.json();
        
        // 画像をセット
        img.src = data.message;

    } catch (error) {
        // エラーの時はアラートを出す
        alert('ごめんなさい！ 通信エラーです🐶💦');
        
    } finally {
        // 3. カーテンを閉める（表示オフ！）
        // 成功でも失敗でも、最後は隠すのがおもてなし
        loadingText.style.display = 'none';
    }
}

btn.addEventListener('click', showDogSafe);
```

### 💡 コラム： `style.display` は「カーテンのひも」

`loadingText.style.display = 'block';`

<img src="./sasie/D11_curtain_display.png" width="800" />

この呪文は、難しく考えずに **「舞台のカーテン」** だと思ってください。

*   **`'block'` （ブロック）**: カーテンを開ける（ジャジャーン！と表示する）。
*   **`'none'` （ナシ）**: カーテンを閉める（完全に消して、見えなくする）。

これをJavaScript（裏方さん）がタイミングよく切り替えることで、「読み込み中」という演出をしているだけなんですね。

### 🧠 初心者さんの、心の旅

  * 「ボタンを押すと、『⏳ 読み込み中...』がパッと出てくる！」
  * 「で、写真が出ると同時に消えた！」
  * 「これがあるだけで、『ちゃんと動いてるんだな』って安心感が全然違うね。」
  * 「`finally` って、このためにあったんだ…。お掃除係、超重要じゃん！」

  <img src="./images/Gemini_Generated_Image_t5bqwjt5bqwjt5bq.png" width="300"/>
  
### 🖼️ おもてなしのフロー（シーケンス図）

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant JS as アプリ(JS)
    participant API as 世界(API)

    User->>JS: ボタンをクリック！
    JS->>User: 🌀 「読み込み中...」を表示
    JS->>API: データをください！(fetch)
    Note right of API: (準備中...)
    API-->>JS: データを返す
    JS->>User: 🐶 画像を表示！
    JS->>User: ✨ 「読み込み中...」を消す(finally)
```

![おもてなしフロー (Loading UI)](./zukai/D11_loading_flow.svg)


-----

<br>  
<br>  
<br>

## 🏡️ハウス・スタンバイ🏡️ミニハウスの「はーぃ、ちょっとお待ち下さい～」

<img src="./images/ChatGPT Image 2025年12月3日 16_00_59.png" width="250"/><br>
人を待たせする時は、『まってくださいね』と伝えるのが礼儀だというセリフ

### 💬「****************************」

<br>  
<br>  
<br>

-----

## ✅ Day 11 のまとめ

今日は、取ってきたデータを「ユーザーに見せる」技術を学びました。

1.  **盛り付け** ： APIから届いたデータ（JSON）を、`img.src` や `div.textContent` に代入して画面を作る。
2.  **おもてなし（UX）** ： `fetch` は時間がかかるので、必ず「ローディング表示」をする。
3.  **`finally` の活用** ： 成功してもエラーになっても、最後に必ずローディングを消すために使う。

これで、あなたのアプリは「データを取ってきて、親切に表示する」ことができるようになりました。  
いわば **「テレビ（受信専用）」** の状態です。

でも、Webアプリの本当の楽しさは、 **「自分のデータを送る（発信）」** ことにあります。  
明日は、あなたのアプリからサーバーに向かってデータを投げ込む、 **「POSTリクエスト」** に挑戦します。

「荷物に宛名を書いて、トラックに乗せる」  
そんな新しい冒険が待っています。お楽しみに！

-----
<br>  
<br>  
<br>

## 📮️ポスト・センド📮️ポストちゃんの「返送」条件

<img src="./images/Gemini_Generated_Image_wkzorowkzorowkzo.png" width="250"/>

宛先だけでなく、どんな種類なのか、全く不明なものは返送されてしまうということをセリフで

### 💬「****************************」

<br>  
<br>  
<br>

-----

## 🍚️本日のイチカ丼のごはん🍚️

### 焼きイモ中の焼き芋

<img src="./images/Gemini_Generated_Image_bqivgkbqivgkbqiv.png" width="300" />

-----

<h1><a href="D12.md">Day12 へ</a></h1>


