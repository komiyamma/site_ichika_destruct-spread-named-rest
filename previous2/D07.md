シリーズ第7回、**Day 7** のコンテンツです。  
昨日の「Promiseチェーン」で、コードは一本道になり、かなり読みやすくなりました。  
でも、人間とは欲深い生き物です。「`.then()` とかカッコ `() => {}` を書くのすら面倒くさい！」「もっと普通の日本語みたいに書きたい！」と思ってしまったのです。

今日は、その願いを叶える現代JavaScriptの最強魔法、**`async`（エイシンク）** と **`await`（アウェイト）** を伝授します。  
これを知ってしまうと、もう元の書き方には戻れないかもしれません…！

-----

# 🕰️ Day 7：魔法の「一時停止」ボタン ～async/await～

## 🪄 7.1 「待て」と言えば、時は止まる

Day 6のコードを見てみましょう。  
チェーンのおかげで綺麗にはなりましたが、まだ少し「プログラミングっぽい記号」が多いですよね。

```javascript
// 昨日のコード（Promiseチェーン）
download()
    .then((data) => {
        return process(data);
    })
    .then((processed) => {
        return display(processed);
    });
```

「もし、この `.then` とか `return` を全部消して、こんなふうに書けたら最高だと思いませんか？」

```javascript
// 理想の書き方（直感）
const data = download();      // ダウンロードして...
const processed = process(data); // 加工して...
display(processed);           // 表示する！
```

「でも、これじゃ『待ち時間』がないから、エラーになっちゃうんでしょ？」

そう、Day 1で学んだ通り、JavaScriptは「止まらない」から、ダウンロードが終わる前に次に行っちゃうんでしたね。  
でも…もし、 **「ここぞという時だけ、シェフ（JavaScript）を一時停止させる魔法」** があったら？

それが、**`await`（待て！）** です。

---

### 🎳ストレート・レーン🎳ピンクボールは一途

<img src="./images/ChatGPT Image 2025年12月17日 01_52_09.png" width="250"/>  

「await」で世界が止まっても、  
私はきっと止まらない！  
大好きなピンに向かって一直線よ！    
というセリフを一言

### 💬「****************************」

-----

## 🎩 7.2 魔法の言葉「async」と「await」

この魔法を使うには、2つのキーワードを覚えるだけでOKです。  


### 1\. `async`（エイシンク）

  * **意味：** 「この関数の中では、時間の魔法を使いますよ」という宣言。
  * **使い方：** 関数の前に書く。
  * **例：** `async function startWork() { ... }`
  * **アシンクの呼称** 「アシンク・アウェイト」の方が、対照的で日本人には言いやすいので、そのように呼称する人も多いです。

### 2\. `await`（アウェイト）

  * **意味：** 「待て！ チケット（Promise）が商品に変わるまで、ここで一時停止せよ！」
  * **使い方：** Promise（時間がかかる処理）の前に書く。
  * **例：** `const coffee = await orderCoffee();`

この2つを使うと、さっきの「理想のコード」が、本当に動くようになるんです！

![async/awaitのタイムライン](./zukai/D07_async_timeline.svg)

### 👮‍♂️ 守るべき2つの「鉄の掟」

この魔法、強力すぎて制限があります。絶対に破ってはいけません。

1.  **`await` は `async function` の中でしか使えない！**
    *   普通の関数の中で `await` と叫んでも、「は？ 何それ？」とエラーになります。
    *   必ず、その関数に `async` マークがついているか確認してください。

2.  **`async function` は必ず「Promise」を返す！**
    *   `async function main() { return 100; }` と書いても、戻ってくるのは `100` ではなく **`Promise<100>`（100が入った箱）** です。
    *   だから、`main()` を呼び出す側も、中身を取り出すために `.then` や `await` が必要になることがあります。

![async/awaitの2つの鉄の掟](./sasie/D07_async_rules.png)

### 🔬 実験：async関数が返すものを見てみよう！

「asyncをつけたらPromiseを返す」を自分の目で確かめましょう。  
コンソールで以下を実行してみてください：

```javascript
// 普通の関数
async function test() {
    return 100;  // ただ 100 を返すだけ
}

// これの中身は何？
console.log(test());
```

**結果：**
```
Promise {<fulfilled>: 100}
```

「え！ 100 じゃなくて Promise が返ってきた！？」

<img src="./images/Gemini_Generated_Image_wky98vwky98vwky9.png" width="300">

そうなんです！ **`async` をつけた瞬間、その関数は自動的にPromiseを返すようになります。**  
だから `main()` に `.catch()` や `.then()` をつけられるのです！

```javascript
// だからこれが動く！
test().then(result => console.log('取り出せた:', result));
// → 取り出せた: 100
```

> 📌 **覚えておこう**  
> `async function` は「中身をPromiseで包んで返す」自動包装機。  
> だから `main().catch(...)` や `await main()` が使える！

### ⚠️ よくある落とし穴：普通の関数からasync関数を呼ぶと？

「async関数はPromiseを返す」と言われても、ピンとこないかもしれません。  
でもこれを知らないと、**謎のバグ**に悩まされることになります！

```javascript
// async関数を定義
async function fetchUserAge() {
    // 何か時間がかかる処理...
    return 25;  // 年齢を返すつもり
}

// ❌ 普通の関数から呼び出すとどうなる？
function showAge() {
    const age = fetchUserAge();  // ← これは25じゃない！
    console.log('あなたの年齢は', age, '歳です');
}

showAge();
```

**結果：**
```
あなたの年齢は Promise {<fulfilled>: 25} 歳です
```

「え！？ `25` じゃなくて `Promise` って表示されてる！？」


<img src="./images/Gemini_Generated_Image_2i7y8b2i7y8b2i7y.png" width="300">


そうなんです！ `async function` は **必ず Promise を返す** ので、  
普通の関数で受け取っても **「中身（25）」ではなく「箱（Promise）」** が入っているのです。

### ✅ 正しい対処法

中身を取り出すには、**呼び出し側でも `.then()` か `await` が必要** です。

```javascript
// 対処法1：呼び出し側もasyncにしてawaitする
async function showAge() {
    const age = await fetchUserAge();  // ← awaitで中身を取り出す！
    console.log('あなたの年齢は', age, '歳です');
}

// 対処法2：.then() で中身を取り出す
function showAge() {
    fetchUserAge().then(age => {
        console.log('あなたの年齢は', age, '歳です');
    });
}
```

> 🎯 **ポイント**  
> `async` 関数を呼んだら、**呼び出し側も「Promiseを受け取った」ことを意識する！**  
> 中身がほしいなら `await` するか `.then()` を使おう！

この2つさえ守れば、あなたは時間の支配者です！

### 💀 見落としがちな第3の掟
さらにもう一つ、絶対に忘れてはいけないルールがあります。

3.  **呼び出し元放置の罠（Unhandled Rejection）**
    *   `async function` はPromiseを返すと説明しましたね。もしその関数の中でエラーが起きたら、そのPromiseは「失敗（Rejected）」状態になります。
    *   これを `await` も `.catch()` もせずに放置すると、**「エラーが起きたのに誰も気づかない（無視される）」** という恐ろしい状態になります。
    *   特に **「ボタンを押した時のイベントハンドラ」** などでやりがちです。


```javascript
// × 危険な書き方
button.addEventListener('click', async () => {
    await dangerousWork(); // ここでエラーが出たら...？
    // 誰もcatchしていないので、エラーは闇に葬られる（またはアプリがクラッシュする）！
});

// ○ 安全な書き方
button.addEventListener('click', () => {
    // ちゃんとcatchで受け止める
    main().catch(e => console.error(e));
});
```
「やりっぱなしはダメ、ゼッタイ」。  
Promiseを返されたら、必ず責任を持って最後まで見届ける（awaitするかcatchする）のが大人のマナーです。

![エラー放置の危険性（Unhandled Rejection）](./sasie/D07_unhandled_rejection.png)

-----

<br>  
<br>  
<br>

## ⏰️ナチュラル・ポーズ⏰️りんりんの「<ruby>時<rt>とき</rt></ruby>のスティック」

<img src="./images/ichika_exercise_tracker_character_rinrin.png" width="225"/>

### 💬 「『待て（await）⏰️』<br>　 　 私がそう唱えれば、結果が出るまで時は止まるの<br>　 　 難しい鎖（チェーン）なんていらないの<br>　 　 ただ、順に願えばいいの⏰️」

<br>  
<br>  
<br>

-----

## ✨ 7.3 劇的ビフォーアフター

では、Day 4の「コールバック地獄」、Day 6の「Promiseチェーン」、そして今日の「async/await」を見比べてみましょう。

<details open>
<summary>🛠️ 実験用のダミー関数（コピペ用）</summary>
上記コードを動かすには、以下の関数を（ダミーとして）先にコンソールで実行しておいてください。

```javascript
// 各種ダミー関数
const download = () => new Promise(resolve => setTimeout(() => resolve('ダウンロードデータ'), 1000));
const process = (data) => new Promise(resolve => setTimeout(() => resolve(data + 'を加工'), 1000));
const display = (data) => new Promise(resolve => {
    console.log('画面に表示:', data);
    resolve();
});

// エラー実験用の「爆発する関数」
const dangerousWork = () => Promise.reject('爆発しました💥');
```
</details>

### 👿 ビフォー（Day 4：コールバック地獄）

```javascript
download((data) => {
    process(data, (processed) => {
        display(processed, () => {
            console.log('完了！');
        });
    });
});
```

### 🔗 プログレス（Day 6：Promiseチェーン）

```javascript
download()
    .then((data) => process(data))
    .then((processed) => display(processed))
    .then(() => console.log('完了！'));
```

### ✨ アフター（Day 7：async/await）

![魔法でスッキリしたコード（魔法の書）](./sasie/D07_simple_spellbook.png)

```javascript
// 魔法を使うための関数を定義
async function main() {
    console.log('🚀 スタート！');

    // awaitをつけるだけで、完了するまでここでピタッと止まってくれる！
    const data = await download(); 
    console.log('1. ダウンロード完了！');

    const processed = await process(data);
    console.log('2. 加工完了！');

    await display(processed);
    console.log('3. 表示完了！');
    
    console.log('🎉 すべて完了！');
}

// 実行！
main();
```

### 🧠 初心者さんの、心の旅

  * 「えっ…？ これ、本当に動くの？」
  * 「`.then` も `callback` もないよ？ 普通に上から下に書いてるだけに見えるけど…。」
  * 「`await download()` って書くと、ダウンロードが終わるまで、次の行に行かずに待っててくれるんだ。まるでDay 1の `alert` みたいに止まってくれる。でもブラウザはフリーズしないの？ すごい魔法だ！」

 <img src="./images/Gemini_Generated_Image_wky98vwky98vwky9.png" width="300"/>

そうなんです！ `await` は、**「見た目は同期処理（上から下）、中身は非同期処理（ちゃんと待つ）」** という、夢のような書き方なんです。

この記述方法は「C\#言語」から発足され、  
非常に優れた記法であるため、他の有名な言語での採用が広がりました。  

### 🎓 コラム：なぜフリーズしないの？

「`await` で止まるなら、Day 1 の `alert` みたいに画面が固まらないの？」

いい質問です！ 実は `await` で止まっている間、シェフ（JavaScript）は **「ただボケーっとしている」わけではありません。**  
裏側では、Day 3 で学んだ **「イベントループ」** が働いています。

1.  `await` にぶつかると、シェフは「あ、これ待ち時間だね」と判断して、**その関数の実行を中断**します。
2.  そして、**「他の仕事（ボタンクリックや画面描画）」に戻るのです！**
3.  Promise（チケット）の結果が出たら、また戻ってきて続きを始めます。

だから、「コードは止まっている（待っている）ように見えるのに、画面はサクサク動く」という魔法が実現できるんですね。

-----

## 🛡️ 7.4 エラーはどうやって捕まえるの？

Promiseチェーンのときは `.catch()` を使いました。  
`async/await` のときは、Day 13（運動アプリ）でチラッと出てきた **`try...catch`** 構文を使います。

「やってみて（try）、ダメだったら捕まえる（catch）」という、直感的な書き方です。

```javascript
async function main() {
    try {
        // ここに「成功するはず」の処理を全部書く
        const data = await download();
        const processed = await process(data);
        await display(processed);
        console.log('🎉 大成功！');

    } catch (error) {
        // 途中で誰かが「失敗（Reject）」したら、すぐにここにワープしてくる！
        console.log('😢 エラーが発生しました:', error);
        
    } finally {
        // 成功しても失敗しても、最後に必ず実行される
        console.log('👋 お疲れ様でした（後片付け）');
    }
}
```

### 🧠 初心者さんの、心の旅

  * 「`.catch()` メソッドをつなげるんじゃなくて、コード全体を `try` ブロックで囲むんだね。」
  * 「ダウンロードで失敗しても、加工で失敗しても、全部 `catch` ブロックに飛んでくるから、エラー処理が一箇所で済む！ これなら私にも書けそう！」

<img src="./images/Gemini_Generated_Image_juatv6juatv6juat.png" width="300" />

-----



<br>  
<br>  
<br>

## 🛡️キープ・シールド🛡️シールド・ナイトは受けて立つ

<img src="./images/Gemini_Generated_Image_973cxq973cxq973c.png" width="300"/>

### 💬 「時間を止められても、矢(エラー)は飛んでくるわ<br>　 　明日は try-catch で盾の構えの訓練よ？<br>　 　あらゆる攻撃を受けて立つ、それがナイトよ🛡️」

<br>  
<br>  
<br>

-----

## ✅ Day 7 のまとめ

今日は、非同期処理の学習における**最大の到達点**にたどり着きました。

### 🎯 覚えるキーワード

| キーワード | 意味 |
|:---|:---|
| `async` | 関数に「時間の魔法を使うよ」と宣言 |
| `await` | Promiseの結果が出るまで一時停止（中身を取り出す） |
| `try...catch` | エラー処理は普通の構文がそのまま使える |

### 📜 3つの掟（復習）

1. **`await` は `async function` の中でしか使えない！**
2. **`async function` は必ず Promise を返す！** → だから `.catch()` がつけられる
3. **Promiseを放置しない！** → `await` か `.catch()` で必ず受け止める

「難しいことは、全部魔法（構文）がやってくれる」  
これが現代のJavaScriptです。

ここまでの7日間で、  
「ワンオペの弱点」を知り、  
「タイマー」で時間を操り、  
「地獄」を味わい、  
「チケット」をもらい、  
ついに **「魔法（async/await）」** を手に入れました。

これで、あなたの手元には最強の武器があります。  
でも、もし「Wi-Fiが切れた」とか「サーバーがダウンした」なんてトラブルが起きたら、どうなってしまうでしょう？

次回は、そんな予期せぬ事故からアプリを守る **「保険（エラーハンドリング）」** について学びます。
転ばぬ先の杖 **`try...catch`** が、あなたを待っています！

-----

## 🍚️本日のイチカ丼のごはん🍚️

![なし](./message/nashi.svg)

<img src="./images/Gemini_Generated_Image_xn5y55xn5y55xn5y.png" width="300" />

### 💬 「えーーーーーーーーーーーーー💦<br>　 　 ごはん無しなんて、<br>　 　 絶対もたないよ～💦」



---

<h1><a href="D08.md">Day8 へ</a></h1>


