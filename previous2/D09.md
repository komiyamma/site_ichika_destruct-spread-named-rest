シリーズ第9回、**Day 9** のコンテンツです。  
昨日の `try...catch` で、エラーが起きても大丈夫な「強いアプリ」になりました。  
でも、人間とは欲深いもの。次は **「もっと速くしたい！」** と思うようになります。

今日は、複数の待ち時間（非同期処理）を **「同時進行（並列）」** させて、劇的に時間を短縮するテクニック **`Promise.all`** を学びます。  
これを覚えると、アプリの体感速度が爆上がりしますよ！

-----

# 🕰️ Day 9：並行処理のテクニック ～Promise.all～

## 🐢 9.1 「ひとつずつ」は丁寧だけど遅い

まずは、Day 7で覚えた `await` を使って、2つの仕事をこなすシーンを想像してみましょう。

**【ミッション】**

1.  **ユーザー情報** を取得する（3秒かかる）
2.  **友達リスト** を取得する（2秒かかる）
3.  両方揃ったら画面に出す

### 今までの書き方（直列処理）

<details open>
<summary>🛠️ 実験用のダミー関数（コピペ用）</summary>
このコードを動かすには、以下の関数を先にコンソールで実行しておいてください。

```javascript
// getUser: 3秒かかる関数
function getUser() {
    return new Promise(resolve => {
        setTimeout(() => resolve({ name: 'イチカ', id: 1 }), 3000);
    });
}

// getFriends: 2秒かかる関数
function getFriends() {
    return new Promise(resolve => {
        setTimeout(() => resolve(['Aさん', 'Bさん']), 2000);
    });
}
// おまけ：お盆をひっくり返す実験用
function getImportantData() { return Promise.resolve('大事なデータ'); }
function getErrorData() { return Promise.reject('エラーデータ'); }
```
</details>

### 本体ソースコード

```javascript
async function loadMyPage() {
    console.time('かかった時間'); // 時間計測スタート！

    // 1. ユーザー情報を取る（3秒待つ）
    const user = await getUser();
    console.log('👤 ユーザー取れた！');

    // 2. 友達リストを取る（2秒待つ）
    const friends = await getFriends();
    console.log('👥 友達取れた！');

    console.log(`✨ 完成！ ${user.name}さんと、友達${friends.length}人`);
    console.timeEnd('かかった時間'); // 時間計測ストップ！
}
```

> 💡 **初めて見る？ `console.time()` と `console.timeEnd()`**
> 
> これは処理時間を計測する便利な道具です！
> ```javascript
> console.time('ラベル名');   // スタート
> // ...何かの処理...
> console.timeEnd('ラベル名'); // ストップ＆経過時間表示
> ```
> 同じラベル名を使うと、その間の時間をコンソールに出してくれます！


### 🧠 初心者さんの、心の旅

  * 「えーっと、3秒待って…よし完了。」
  * 「次に2秒待って…よし完了。」
  * 「合計で… **3秒 + 2秒 = 5秒** かかったね。」
  * 「うーん、丁寧だけど、ちょっと待ちくたびれちゃうな。友達リストを取るのに、ユーザー情報が終わるのを待つ必要あるのかな？」

<img src="./images/Gemini_Generated_Image_a92kq1a92kq1a92k.png" width="300" />

そうなんです！ この2つの仕事は **お互いに関係がない（独立している）** ので、順番待ちをする必要がないんです。

-----

## 🏎️ 9.2 「せーの！」で同時に頼む ～Promise.all～

カフェで例えるなら、さっきのコードは **「コーヒーを頼んで、受け取ってから、トーストを頼む」** ようなものです。非効率ですよね？  
普通は **「コーヒーとトースト、両方ください！」** とまとめて注文します。

それを実現するのが、**`Promise.all`（プロミス・オール）** です！

### 書き方のルール

1.  `await` を個別に書かない（注文だけ先に通す）。
2.  `Promise.all([ ... ])` の中に、待ちたいものを配列で全部入れる。
3.  `Promise.all` 自体に `await` をかける。

<img src="./sasie/D09_parallel_waitress.png" width="600" />

<!-- end list -->

### Step 1：まずは普通の書き方で理解しよう

```javascript
async function loadMyPageFast() {
    console.time('爆速タイム');

    // 1. ここでは「await」しない！ 注文だけ先に通す（リクエスト発射！）
    // チケット（Promise）だけもらって、手元に置いておく
    const userPromise = getUser();       // 3秒の処理
    const friendsPromise = getFriends(); // 2秒の処理

    console.log('🚀 両方同時に注文しました！');

    // 2. Promise.allを使って「全部揃うまで待て！」
    // 結果は「配列」で返ってくる
    const results = await Promise.all([userPromise, friendsPromise]);
    
    // 3. 配列から取り出す
    const user = results[0];    // 0番目がユーザー
    const friends = results[1]; // 1番目が友達

    console.log(`✨ 完成！ ${user.name}さんと、友達${friends.length}人`);
    console.timeEnd('爆速タイム');
}
```

この書き方なら分かりやすいですね！  
`Promise.all` は結果を **配列** で返すので、`results[0]`、`results[1]` で取り出します。

### Step 2：ショートカット（分割代入）でスッキリ書く

実は、上の3行を **1行** で書けるショートカットがあります！

```javascript
// さっきの3行が...
const results = await Promise.all([userPromise, friendsPromise]);
const user = results[0];
const friends = results[1];

// ⇩ この1行になる！（分割代入）
const [user, friends] = await Promise.all([userPromise, friendsPromise]);
```

「左側に `[ ]` があるのは何？」と思った人、正常な反応です！ 😄  
これは **「分割代入（Destructuring Assignment）」** というJavaScriptの構文です。

> 📚 **分割代入とは？**
> 
> 配列の中身を、順番に別々の変数に取り出すテクニックです。
> 
> ```javascript
> // 普通の書き方
> const fruits = ['りんご', 'みかん'];
> const first = fruits[0];   // 'りんご'
> const second = fruits[1];  // 'みかん'
> 
> // 分割代入（ショートカット）
> const [first, second] = ['りんご', 'みかん'];
> // first = 'りんご', second = 'みかん'
> ```
> 
> 「配列の左から順番に、変数に入れていく」と覆えておけばOK！
> 
> ⚠️ **今回使うのは『配列の分割代入 `[ ]`』だけ！**  
> JavaScriptには、オブジェクトを分解する別の書き方（`const { name } = user`）もありますが、それはまた別の話。今は気にしなくてOKです！

### 🧠 初心者さんの、心の旅

  * 「結果は… **3秒** ！？ ええっ！？」

  <img src="./images/Gemini_Generated_Image_wky98vwky98vwky9.png" width="300"><br>
  
  * 「そうか！ 『ヨーイドン』で同時にスタートしてるから、**一番遅い方（3秒）が終わった時点で、両方揃ってる**ことになるんだ！」
  * 「2秒の方は、途中で終わってるけど、3秒の方が終わるまで一緒に待っててくれるんだね。」

### 🖼️ 直列 vs 並列

![直列と並列の違い](./zukai/D09_promise_all_parallel.svg)

これだけで、アプリの待ち時間が **5秒 → 3秒** に短縮されました。  
もし仕事が10個あったら…効果は絶大ですよね！

-----

### 🚧 【上級者コラム】 どんな時でも速くなるわけじゃない？

「よーし、じゃあJavaScriptの計算も全部 `Promise.all` にすれば１００倍速だ！」

<img src="./images/Gemini_Generated_Image_juatv6juatv6juat.png" width="300">

…と思ったあなた、ちょっとストップです！ ✋

実は、`Promise.all` が並列で速くなるのは、**「待ち時間（ネットワーク通信や、データベースへの読み書き）」** の時だけなんです。

*   **得意なこと（I/O処理）**:
    *   外部のサーバーからデータを取ってくる
    *   ファイルを読み込む
    *   タイマーで待つ
    *   👉 **これらは、ブラウザ(C++)やお母さん（OS）が裏でやってくれるので、JavaScriptは待っていられる = 並列できる！**

*   **不得意なこと（CPU処理）**:
    *   超巨大な配列の計算ループ
    *   画像処理
    *   👉 **これらは、JavaScript自身が計算しないといけないので、`Promise.all` にしても結局１人が順番にこなすだけ（並列にならない）。**

    <img src="./sasie/D09_single_thread_serial_processing.png" width="600" />

JavaScriptは基本的に **「シングルスレッド（体は１つ）」** です。  
もし「計算」も同時にやりたい場合は、別の技術（Web Workersなど）が必要になりますが、それはまた別の物語（Day14）で！

今の **「待ち時間がある仕事は、`Promise.all` で重ねると速い！」** （待ち時間の並列化）という理解で完璧です。

-----

### 🔬 【実験】「まな板１つ」の真実を確かめよう！

「本当にJavaScriptで計算したら並列にならないの？」  
疑り深い人のために、**実験**を用意しました。  
同じ「1秒＋2秒＋3秒」の待ち時間でも、**「誰が」待っているか**で結果が変わることを体感してみましょう！

#### 🎓 実験の前に：Day 3 の「まな板」を思い出そう

Day 3 で学んだ「まな板（コールスタック）」を覚えていますか？  
JavaScriptのシェフは **まな板を１つしか持っていない** から、同時に２つの料理はできませんでしたね。

この実験では、その「まな板」がどう使われるかの違いを見ます。

-----

#### ✅ 実験A：`setTimeout`（ブラウザに任せる）→ 速い！

<details open>
<summary>🛠️ 実験用コード（コピペ用）</summary>

```javascript
// ブラウザ(C++)に「待つ仕事」を任せる関数群
function waitWithTimer(seconds) {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log(`⏰ ${seconds}秒のタイマー完了！`);
            resolve();
        }, seconds * 1000);
    });
}

// Promise.all で同時に開始！
async function testTimerParallel() {
    console.log('🚀 スタート！');
    console.time('⏱️ かかった時間');
    
    // 1秒・2秒・3秒を「同時に」スタート！
    await Promise.all([
        waitWithTimer(1),  // 1秒
        waitWithTimer(2),  // 2秒
        waitWithTimer(3)   // 3秒
    ]);
    
    console.timeEnd('⏱️ かかった時間');
    console.log('🎉 全部完了！');
}

testTimerParallel();
```
</details>

**結果（約3秒で完了！）：**
```
🚀 スタート！
⏰ 1秒のタイマー完了！
⏰ 2秒のタイマー完了！
⏰ 3秒のタイマー完了！
⏱️ かかった時間: 3003ms  ← 🎉 1+2+3=6秒ではなく、約3秒！
🎉 全部完了！
```

「やったー！ 並列化成功！」  
これは、**シェフ（JavaScript）がタイマーをセットしたら、ブラウザ（C++）に任せて自分は手を空けている**からです。

![setTimeoutはブラウザが裏で処理、シェフは待つだけ](./zukai/D09_timer_vs_while_parallel.svg)

-----

#### ❌ 実験B：`while`ループ（自分で計算する）→ 遅い…＆フリーズ！

では、タイマーを使わずに **「JavaScript自身が時間を計りながらループで待つ」** とどうなるでしょう？

> ⚠️ **警告：このコードはブラウザを６秒ほどフリーズさせます！**  
> 実行する場合は、他のタブで大事な作業をしていないことを確認してください。  
> フリーズしたらタブを閉じれば復帰できます。

<details open>
<summary>🛠️ 実験用コード（コピペ用・注意！）</summary>

```javascript
// JavaScript自身が「ずっと回って待つ」関数
function waitWithWhile(seconds) {
    return new Promise(resolve => {
        const start = Date.now();
        const waitMs = seconds * 1000;
        
        // while で「指定秒数」が経つまでグルグル...
        while (Date.now() - start < waitMs) {
            // 何もしないけど、CPUは動き続ける！
            // まな板（コールスタック）を占領したまま！
        }
        
        console.log(`🔄 ${seconds}秒のwhileループ完了！`);
        resolve();
    });
}

// Promise.all で同時に開始...できる？
async function testWhileParallel() {
    console.log('🚀 スタート！ ※画面がフリーズするかも...');
    console.time('⏱️ かかった時間');
    
    await Promise.all([
        waitWithWhile(1),  // 1秒
        waitWithWhile(2),  // 2秒
        waitWithWhile(3)   // 3秒
    ]);
    
    console.timeEnd('⏱️ かかった時間');
    console.log('🎉 全部完了！');
}

testWhileParallel();
```
</details>

**結果（約6秒かかる…しかもフリーズ！）：**
```
🚀 スタート！ ※画面がフリーズするかも...
🔄 1秒のwhileループ完了！
🔄 2秒のwhileループ完了！
🔄 3秒のwhileループ完了！
⏱️ かかった時間: 6002ms  ← 💥 1+2+3=6秒かかった！並列じゃない！
🎉 全部完了！
```

「えっ！？ `Promise.all` を使ったのに、1+2+3=6秒かかってる！」  
しかも、**実行中は画面がフリーズして、ボタンも押せなかった**はずです。

![まな板1つの制約](./zukai/D09_while_serial.svg)

-----


#### 🧠 なぜ結果が違うの？

Day 1 と Day 3 を振り返ってみましょう。

| | `setTimeout`（実験A） | `while`ループ（実験B） |
|:---|:---|:---|
| **誰が待つ？** | **ブラウザ（C++）** が裏で計測 | **JavaScript** が自分でグルグル |
| **まな板の状況** | シェフはすぐ手を空けて、次の注文を受ける | シェフがまな板を **占領し続ける** |
| **並列化** | ⭕ できる！（シェフは待ってるだけ） | ❌ できない！（シェフが忙しい） |
| **フリーズ** | しない（シェフは他の仕事ができる） | **する！**（ボタンが押せない） |

#### 💡 ポイント：「誰がその時間を使っているか？」

*   **ブラウザ（C++）が時間を管理**している場合（`setTimeout`、`fetch`など）  
    → シェフ（JavaScript）は手が空いているので、**他の仕事を同時進行できる！**

*   **JavaScript自身が処理**している場合（`while`ループ、巨大配列の計算など）  
    → シェフがまな板を**占領し続ける**ので、**何も並列にならない！**

> 📌 **覚えておこう**  
> `Promise.all` は「魔法の並列化」ではありません。  
> **「まな板１つ」の制約は変わらない**のです。  
> シェフが手を空けてくれる処理（I/O待ち）だけが、並列化の恩恵を受けられます。

Day 14-15 で学ぶ「Web Workers」を使えば、別のシェフ（スレッド）を雇えるので、  
`while` のような重い計算も並列にできるようになります。でも、それはまた別の物語！

-----

### 🏃‍♀️ まとめ：分割代入の復習

さっき学んだ分割代入、もう一度確認しておきましょう！

```javascript
/* 普通の書き方（3行） */
const results = await Promise.all([ ... ]);
const user = results[0];
const friends = results[1];

/* 分割代入（1行） */
const [user, friends] = await Promise.all([ ... ]);
```

どちらでもOKですが、他の人のコードでよく見るので、**「読める」ようになっておくと役立ちます！**

-----

## ⚠️ 9.3 お盆をひっくり返さないで！

`Promise.all` は強力ですが、一つだけ弱点（というか特徴）があります。  
それは、 **「一蓮托生（いちれんたくしょう）」** だということです。

![Promise.allの一蓮托生（全体責任）のイメージ](./sasie/D09_promise_all_flow.png)

カフェで、コーヒーとトーストを一つのお盆に乗せて運んでくるところを想像してください。  
もし、運んでいる途中で**コーヒーをこぼしてしまったら（エラー発生）**、どうなりますか？

トーストが無事でも、店員さんは **「申し訳ありません！ 作り直します！」と言って、お盆ごと全部下げてしまいます。**

![お盆をひっくり返してパニックになるウェイター](./sasie/D09_dropping_tray_panic.png)


### ルール：一つでも失敗したら、即エラー

`Promise.all` の中に入れた処理が、**一つでも「失敗（Reject）」すると、他の処理が成功していても、全体が `catch` に飛んでしまいます。**

```javascript
try {
    const results = await Promise.all([
        getImportantData(), // 成功
        getErrorData()      // 失敗💥
    ]);
} catch (error) {
    console.log('😭 全滅です…成功したデータも受け取れません');
}
```

「成功したものだけでも欲しい！」という場合は、もっと高度な技（`Promise.allSettled`）がありますが、まずは **「`Promise.all` は全員成功が条件のチームプレー」** と覚えておけばOKです。

-----

<br>  
<br>  
<br>

## 🦑イカイカ・アシアシ🦑 ショートク・タイカはマルチタスク

<img src="./images/ChatGPT Image 2025年12月7日 21_57_29.png" width="225"/>

「聖徳太子」と同じように、足が10本あるこの「イカ」は、  
マルチタスクが得意なことを自慢します。

### 💬「****************************」

<br>  
<br>  
<br>

-----

## ✅ Day 9 のまとめ

今日は、複数の仕事を効率よくさばくためのテクニックを学びました。

1.  **直列処理（`await` の連続）** ：
      * 丁寧だけど、前の仕事が終わるまで次が進まない。「足し算」の時間（3秒+2秒=5秒）がかかる。
2.  **並列処理（`Promise.all`）** ：
      * 複数の仕事を「せーの」で開始する。
      * **「一番遅い仕事」の時間（3秒）だけで済む！**
3.  **注意点** ：
      * 一つでもコケたら、連帯責任で全部エラーになる（catchに飛ぶ）。

これで、非同期処理の基本技（待つ、エラー対応、並列化）はコンプリートです！  
あなたはもう、JavaScriptの時間を自在に操れる「時の魔術師」です🧙‍♀️

明日からは、いよいよ **Part 3**。  
この魔術を使って、**「自分のPCの外側（インターネット）」からデータを取ってくる冒険、`fetch()` API** の世界へ飛び込みます。

「今日の天気は？」「最新のニュースは？」  
あなたのアプリが、世界と繋がる瞬間です。お楽しみに！

-----

## 🍚️本日のイチカ丼のごはん🍚️

### 寿司サーモン

<img src="./images/ChatGPT Image 2025年12月20日 19_49_40.png" height="300" />


-----

<h1><a href="D10.md">Day10 へ</a></h1>


